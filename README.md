# SimPL
An interpreter for SimPL (a simplified dialect of ML, supporting both functional and imperative programming) implemented in Java.

## Introduction

As specified in [./SimPL-Specification-v4.4.pdf](https://github.com/WMBao/SimPL/blob/master/SimPL-Specification-v4.4.pdf "SimPL specification document"), the target of this project is to implement an interpreter for SimPL, a simplified variant of the programming language ML. 
A well-designed skeleton on Java is provided along with detailed specifications of SimPL.

Basic requirements, as illustrated in Fig. 1 mainly include the implementation of the typing and evaluation system. 

![Missing Image](https://github.com/WMBao/SimPL/blob/master/image/1.png)

Additional requirements include implementation of **garbage collection**, **polymorphic types**, **lazy evaluation**, etc.

## Achievements
All the basic requirements for a SimPL interpreter are achieved on all the test SimPL programs provided in the ./doc/examples.

A **Mark-and-Sweep garbage collector**, **polymorphic types**, and the **Call-by-Need evaluation strategy (lazy evaluation)** are implemented.

## Implementation

### Lexical and Syntactical Analysis

Lexical analysis is conducted with a lexical analyzer generated by JFlex. 

Syntactical analysis is conducted with a parser generated by JavaCUP.

### Type check

The type checking system is mainly relying on Type Inference, implemented in ``typecheck()`` function calls. 

The main purpose is to type-check the nested expressions and generate the type of the untyped source program if possible.

From a general perspective, the main steps include adding the typing scheme, generate constraints, solving or simplifying constraints and applying the solution.

### Evaluation

Intuitively, SimPL programs are nested expressions organized in Abstract Syntax Trees. 

After the type-checking process, the evaluation system deals with nested expressions recursively with ``eval()`` function calls.


## Bonus

### Garbage Collection

Simple as SimPL is, there exists the possibility for orphans to be createdï¼Œ due to assignments and memory references.

Basically, the garbage collector is triggered when the heap is full. 

All the referenced cells are marked and the unmarked orphans are swept.

The heap size (memory) is restricted to be 2, which is an extreme condition only for illustration on the following testcase.

```ML
let f = fn x => r e f 1 in
	let y = r e f 2 in
		! ( f 1) + ! y + ! ( f 1)
	end
end
```
During the evaluation of the two let expressions, value 1 and value 2 are put into the heap before the evaluation of the right-hand-side (RHS) expression.

While during the evaluation of  ``!(f 1) + !y + !(f 1)``, orphans are generated right before the evaluation of the second ``!(f 1)`` in Call-by-Need evaluation strategy.

The output of the sample program is as follows.
```
int
--- Before: ---
2
1
collect0
collect1
--- After: ---
null
null
GC completed
4
```

### Polymorphic Types


When an unknown type comes, it is represented with ``Type.IDENTIFY`` and a name ``tv + tvcount``. 
``tvcount`` will increase every time an unknown type is encountered, as is illustrated in the implementation code for ``TypeVar`` below.

```Java
public TypeVar (boolean equal i tyType ) {
	this . equal i tyType = equal i tyType ;
	name = Symbol . symbol ( " tv " + ++tvcnt ) ;
}
```

With the following SimPL source program, 

```ML
rec map =>
	fn f => fn l =>
		if l=nil
		then nil
		else ( f (hd l ) ) : : (map f ( tl l ) )
```

the type-checking result is ``((tv33 -> tv34) -> (tv33 list -> tv34 list))``.


### Lazy Evaluation

In Lazy Evaluation strategy, an expression will never be evaluated until its value is needed, which is also called Call-by-Need evaluation strategy.

As is specified in the evaluation rules, a Short-Circuit-Evaluation like policy is applied to AndAlso and OrElse.

The code of ``eval()`` in ``AndAlso`` is as follows.

```Java
public Value eval ( State s ) throws RuntimeError f
	BoolValue lv = ( BoolValue ) l . eval ( s ) ;
	if ( ! lv . b)
	// E-AndAlso2
		return new BoolValue ( false ) ;
	else {
		BoolValue rv = ( BoolValue ) r . eval ( s ) ;
		// E-AndAlso1
		return new BoolValue ( rv . b) ;
	}
}
```

If the left value ``lv`` is false, the right value ``rv`` will not be evaluated.

The code of ``eval()`` in ``OrElse`` is as follows.

```Java
public Value eval ( State s ) throws RuntimeError f
	BoolValue lv = ( BoolValue ) l . eval ( s ) ;
	if ( lv . b == true )
	// E-OrElse1
	return new BoolValue ( true ) ;
	else {
		// E-OrElse2
		BoolValue rv = ( BoolValue ) r . eval ( s ) ;
		return new BoolValue ( rv . b) ;
	}
}
```
